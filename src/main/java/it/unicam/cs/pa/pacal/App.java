/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package it.unicam.cs.pa.pacal;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 *
 */
public class App<T extends BasicCalcState> {

    public enum CALCULATOR_TYPE {
        BASIC, SIMPLE, EXTENDED, STACK
    }

    private Map<String, Consumer<? super T>> commands;
    private T state;

    public static final Consumer<BasicCalcState> SUM_FUNCTION = c -> c.setValue(c.getValue2()+c.getValue1());
    public static final Consumer<BasicCalcState> DIF_FUNCTION = c -> c.setValue(c.getValue2()-c.getValue1());
    public static final Consumer<BasicCalcState> MUL_FUNCTION = c -> c.setValue(c.getValue2()*c.getValue1());
    public static final Consumer<BasicCalcState> DIV_FUNCTION = c -> c.setValue(c.getValue2()/c.getValue1());

    public App( Map<String, Consumer<? super T>> commands, T state ) {
        this.commands = commands;
        this.commands.put("help",s -> printCommands());
        this.state = state;
    }

    public static void main(String[] args) throws IOException {
        if (args.length == 0) {
            createBasicCalculator().start();
        } else {
            try {
                Objects.requireNonNull(createCalculator(args[0])).start();
            } catch (IllegalArgumentException e) {
                System.err.println("Calculator "+args[0]+" is unknown!");
            }
        }
    }

    private static App<?> createCalculator(String code) {
        switch (CALCULATOR_TYPE.valueOf(code.toUpperCase())) {
            case BASIC:
                return createBasicCalculator();
            case SIMPLE:
                return createSimpleCalculator();
            case EXTENDED:
                return createExtendedCalculator();
            case STACK:
                return createStackCalculator();
        }
        return null;
    }

    public void start() throws IOException {
        hello();
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        while (state.isOn()) {
            printState();
            System.out.print(" > ");
            System.out.flush();
            String command = reader.readLine();
            processCommand(command);
        }
        printGoodbye();
    }

    private void printGoodbye() {
        System.out.println("\n\nThank you for having used our calculator!");
        System.out.println("See you next time!\n\n");
    }

    private void hello() {
        System.out.println("******************************");
        System.out.println("*         PACALC 0.1         *");
        System.out.println("******************************");

    }

    private void printCommands() {
        TreeSet<String> words = new TreeSet<>(commands.keySet());
        String[] wordsArray = words.toArray(new String[] {});
        System.out.println("Commands: "+ Arrays.toString(wordsArray));
    }

    private void processCommand(String command) {
        try {
            double value = Double.parseDouble(command);
            state.setValue(value);
        } catch (NumberFormatException e) {
            Consumer<? super T> action = commands.get(command);
            if (action == null) {
                System.err.println("Unknown command: "+command);
            } else {
                action.accept(state);
            }
        }
    }

    public void printState() {
        System.out.println(state.toString());
    }

    public static <T extends BasicCalcState> void addSimpleMathFunctions(HashMap<String,Consumer<? super T>> commands) {
        commands.put("+",createCommand(Double::sum));
        commands.put("-",createCommand((x,y) -> x-y));
        commands.put("/",createCommand((x,y) -> x/y));
        commands.put("*",createCommand((x,y) -> x*y));
    }

    public static <T extends BasicCalcState> void addComplexMathFunctions(HashMap<String,Consumer<? super T>> commands) {
        commands.put("abs",createCommand(Math::abs));
        commands.put("pow",createCommand(Math::pow));
        commands.put("sqrt",createCommand(Math::sqrt));
        commands.put("log",createCommand(Math::log));
        commands.put("exp",createCommand(Math::exp));
    }


    public static <T extends BasicCalcState> void addControllingCommands(HashMap<String,Consumer<? super T>> commands) {
        commands.put("exit", BasicCalcState::turnOff);
        commands.put("delete",s -> s.setValue(0.0));
        commands.put("clear",BasicCalcState::reset);
    }

    public static App<BasicCalcState> createBasicCalculator() {
        HashMap<String,Consumer<? super BasicCalcState>> commands = new HashMap<>();
        addSimpleMathFunctions(commands);
        addControllingCommands(commands);
        return new App<>(commands, new BasicCalcState());
    }

    public static App<SingleMemoryCalcState> createSimpleCalculator() {
        HashMap<String,Consumer<? super SingleMemoryCalcState>> commands = new HashMap<>();
        addSimpleMathFunctions(commands);
        addControllingCommands(commands);
        commands.put("store",SingleMemoryCalcState::store);
        commands.put("call",SingleMemoryCalcState::call);
        return new App<>(commands, new SingleMemoryCalcState());
    }

    public static App<DoubleMemoryCalcState> createExtendedCalculator() {
        HashMap<String,Consumer<? super DoubleMemoryCalcState>> commands = new HashMap<>();
        addSimpleMathFunctions(commands);
        addControllingCommands(commands);
        addComplexMathFunctions(commands);
        commands.put("store1",DoubleMemoryCalcState::storeToMem1);
        commands.put("store2",DoubleMemoryCalcState::storeToMem2);
        commands.put("call1",DoubleMemoryCalcState::call1);
        commands.put("call2",DoubleMemoryCalcState::call2);
        return new App<>(commands, new DoubleMemoryCalcState());
    }

    public static App<StackMemoryState> createStackCalculator() {
        HashMap<String,Consumer<? super StackMemoryState>> commands = new HashMap<>();
        addSimpleMathFunctions(commands);
        addControllingCommands(commands);
        addComplexMathFunctions(commands);
        commands.put("pop",StackMemoryState::pop);
        commands.put("push",StackMemoryState::push);
        return new App<>(commands, new StackMemoryState());
    }


    public static Consumer<BasicCalcState> createCommand(Function<Double,Double> f ) {
        return s -> s.setValue(f.apply(s.getValue1()));
    }

    public static Consumer<BasicCalcState> createCommand(BiFunction<Double,Double,Double> f) {
        return s -> s.setValue(f.apply(s.getValue2(),s.getValue1()));
    }


}
